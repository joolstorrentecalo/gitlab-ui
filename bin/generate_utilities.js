/* eslint-disable no-console */
const fs = require('fs');
const path = require('path');
const postcss = require('postcss');
const postcssScss = require('postcss-scss');

const scssDir = path.join(__dirname, '..', 'src', 'scss');
const mixinsPath = path.join(scssDir, 'utility-mixins');
const utilitiesPath = path.join(scssDir, 'utilities.scss');

const statefulUtilitiesRegexp = /\$(active|hover|visited|focus): true/g;

const IGNORE_RESPONSIVE_ORDERING = 'gitlab-ui/generate_utilities/ignore-responsive-ordering';
const RESPONSIVE_ORDER = ['xs', 'sm', 'md', 'lg', 'xl'];

const hasIgnoreResponsiveOrdering = comment => comment.text.includes(IGNORE_RESPONSIVE_ORDERING);

const getResponsiveKey = selector => RESPONSIVE_ORDER.find(size => selector.startsWith(`gl-${size}-`));

const getRuleName = (mixinDeclaration) => mixinDeclaration.match(/[\w-]+/)[0];

const getStatefulFlags = (mixinDeclaration) =>
  [...mixinDeclaration.matchAll(statefulUtilitiesRegexp)].map((match) => match[1]);

const buildUtilityClass = (name, important = false) => {
  const baseSelector = `.${name}`;
  const selector = important ? `${baseSelector}\\!` : baseSelector;

  return postcss.rule({ selector });
};

const buildStatefulClasses = (name, statefulFlags = [], important = false) => {
  return statefulFlags.map((statefulFlag) => {
    const baseSelector = `.gl-${statefulFlag}-${name.replace('gl-', '')}$1:${statefulFlag}`;
    const selector = baseSelector.replace('$1', important ? '\\!' : '');

    return postcss.rule({ selector });
  });
};

const buildImportantDecl = (originalDecl) => {
  return originalDecl.clone({ important: true });
};

const createRuleWithImportantDecls = (rule) => {
  const importantDeclsRule = rule.clone();

  importantDeclsRule.walkDecls((decl) => decl.replaceWith(buildImportantDecl(decl)));

  return importantDeclsRule;
};

const resolveDeclarations = (rule, allDeclarations = {}) => {
  const ruleDeclarations = [];

  rule.walkDecls((decl) => ruleDeclarations.push(decl));
  rule.walkAtRules('include', (includeRule) => {
    const mixinName = getRuleName(includeRule.params);
    const decls = allDeclarations[mixinName];

    if (decls) {
      includeRule.replaceWith(...decls);
    } else {
      console.warn(`Could not find declarations for mixin ${mixinName}`);
    }
  });

  return ruleDeclarations;
};

/**
 * This finds a media query within the children and replaces it with the query's children
 * 
 * Input:
 * .gl-sm-foo {
 *   @media (min-width: $breakpoint-sm) {
 *     content: 'foo';
 *   }
 * }
 * 
 * Output:
 * .gl-sm-foo {
 *   content: foo;
 * }
 */
const removeMediaQueryWrapper = (rule) => {
  const orphans = [];

  rule.nodes.filter(x => x.type === 'atrule' && x.name === 'media').forEach(media => {
    orphans.push(...media.clone().nodes);
    media.remove();
  });

  rule.append(...orphans);

  return rule;
}

/**
 * This context contains the info for creating the final output.
 * 
 * It is mutated by our parser so that certain nodes can go in certain 
 * layers (e.g. the responsive media queries) in order to preserve the
 * necessary ordering for responsive classes.
 */
const createContext = () => ({
  layers: {
    main: [],
    xs: [],
    sm: [],
    md: [],
    lg: [],
    xl: [],
  }
})

/**
 * PostCSS plugin that generates utility classes based on the utility-mixin
 * declarations in /src/scss/utility-mixins
 *
 * To understand the AST generated by PostCSS, read PostCSS API documentation
 * http://api.postcss.org/index.html
 */
const createGenerateUtilitiesPlugin = (context) => postcss.plugin('postcss-generate-utilities', () => {
  return (root) => {
    let shouldEnforceResponsiveOrder = true;
    const allDeclarations = {};

    root.walkComments((comment) => {
      if (hasIgnoreResponsiveOrdering(comment)) {
        shouldEnforceResponsiveOrder = false;
      }

      comment.remove();
    });
    root.walkAtRules('import', (rule) => rule.remove());

    root.walkAtRules('mixin', (rule) => {
      const { params } = rule;
      const mixinName = getRuleName(params);
      const statefulFlags = getStatefulFlags(params);
      const utilityClasses = [
        buildUtilityClass(mixinName),
        ...buildStatefulClasses(mixinName, statefulFlags),
      ];
      const importantUtilityClasses = [
        buildUtilityClass(mixinName, true),
        ...buildStatefulClasses(mixinName, statefulFlags, true),
      ];
      allDeclarations[mixinName] = resolveDeclarations(rule, allDeclarations);
      const importantDeclsRule = createRuleWithImportantDecls(rule);

      const responsiveKey = shouldEnforceResponsiveOrder && getResponsiveKey(mixinName);

      const nodesToAdd = [
        ...utilityClasses.map(utilityClass => utilityClass.append(...rule.clone().nodes)),
        ...importantUtilityClasses.map(utilityClass => utilityClass.append(...importantDeclsRule.clone().nodes))
      ];

      if (!responsiveKey) {
        // If not responsive, append to root... It's going to layers.main
        nodesToAdd.forEach(node => root.append(node));
      } else {
        // If responsive, append to the right layer.
        context.layers[responsiveKey].push(...nodesToAdd.map(removeMediaQueryWrapper));
      }

      rule.remove();
    });
  };
});

function writeFileHeader() {
  try {
    fs.appendFileSync(utilitiesPath, '/* auto-inject-scss-lib */\n');
    console.log(`Successfully wrote header to ${utilitiesPath}`);
  } catch (e) {
    console.error(`Could not write header to ${utilitiesPath}`);
    throw e;
  }
}

function createMediaQueryRule(size, nodes = []) {
  return postcss.atRule({
    name: 'media',
    params: `(min-width: $breakpoint-${size})`,
    nodes,
  });
}

function writeUtilities(context) {
  const contents = context.layers.main.join('\n');

  fs.appendFileSync(utilitiesPath, contents);

  RESPONSIVE_ORDER
    .filter(size => context.layers[size]?.length)
    .forEach(size => {
      const children = context.layers[size];
      const sizeRule = createMediaQueryRule(size, children);

      const sizeLayerContent = `${sizeRule.toString(postcssScss)}\n`;

      fs.appendFileSync(utilitiesPath, sizeLayerContent);
    });
}

function main() {
  try {
    if (fs.existsSync(utilitiesPath)) {
      fs.unlinkSync(utilitiesPath);
    }

    writeFileHeader();

    const files = fs.readdirSync(mixinsPath);
    const context = createContext();
    const utilitiesPlugin = createGenerateUtilitiesPlugin(context);

    const result = Promise.all(files.map((file) => {
      const scss = fs.readFileSync(path.join(mixinsPath, file), { encoding: 'utf-8' });

      return postcss([utilitiesPlugin])
        .process(scss, { from: file, to: utilitiesPath, syntax: postcssScss })
        .then((result) => { 
          context.layers.main.push(result.css)
        })
        .catch((e) => {
          console.log('Could not generate utilities.scss', e);
        });
    }));

    result.then(() => {
      writeUtilities(context)
    }).catch(e => {
      console.error('Something went wrong! ', e);
    });
  } catch (e) {
    console.error(`Could not read ${mixinsPath}`);
    throw e;
  }
}

main();
