@mixin str-truncated($max-width: 82%) {
  display: inline-block;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: top;
  white-space: nowrap;
  max-width: $max-width;
}

/**
* Helper function for :focus
*
* @param $size is deprecated and should not be used anymore
*/
@mixin gl-focus(
  $size: null,
  $color: false,
  $important: false,
  $inset: false,
  $focus-ring: $focus-ring,
  $outline: false,
  $outline-offset: $outline-offset
) {
  @if $inset == true {
    @if $color {
      box-shadow: inset 0 0 0 $outline-width $blue-400,
        inset 0 0 0 #{$outline-width + $outline-offset} $white,
        inset 0 0 0 #{$outline-width + $outline-offset + 1px} $color,
        $focus-ring-inset if-important($important);
      outline: none if-important($important);
    } @else if $outline == true {
      outline: $focus-ring-outline if-important($important);
      outline-offset: $outline-offset;
    } @else {
      box-shadow: inset 0 0 0 $outline-width $blue-400, $focus-ring-inset if-important($important);
      outline: none if-important($important);
    }
  } @else if $color {
    box-shadow: inset 0 0 0 $gl-border-size-1 $color, $focus-ring if-important($important);
    outline: none if-important($important);
  } @else if $outline == true {
    outline: $focus-ring-outline if-important($important);
    outline-offset: $outline-offset;
  } @else {
    box-shadow: $focus-ring if-important($important);
    outline: none if-important($important);
  }
}

@mixin gl-bg-gradient-blur($direction, $color) {
  background-image: linear-gradient(to $direction, $transparent-rgba, $color 33%);
}

/**
* Helper function for @media of at least the minimum
* breakpoint width.
*
* @param $name Breakpoint name, such as `sm` or `md`.
*/
@mixin gl-media-breakpoint-up($name) {
  $min: map-get($breakpoints, $name);
  @if $min == null {
    @error "#{$name} is not a valid breakpoint for this @media query.";
  }
  @if $min != 0 {
    @media (min-width: $min) {
      @content;
    }
  } @else {
    @content;
  }
}

/**
* Helper function for @media of at most the maximum
* breakpoint width.
*
* Note: Before using, consider using a mobile-first
* approach, and define @media for larger breakpoints
* using `gl-media-breakpoint-up` while using this rule as
* the starting point instead.
*
* @param $name Breakpoint, such as `sm` or `md`. `xs` is not valid
*/
@mixin gl-media-breakpoint-down($name) {
  $max: map-get($breakpoints, $name);
  @if ($max == null or $max == 0) {
    @error "#{$name} is not a valid breakpoint for this @media query.";
  }
  // The maximum value is reduced by 0.02px to work around the limitations of
  // `min-` and `max-` prefixes and with fractional viewport sizes.
  // See: https://www.w3.org/TR/mediaqueries-4/#mq-min-max
  // Use 0.02px rather than 0.01px to work around a current rounding bug in Safari.
  // See https://bugs.webkit.org/show_bug.cgi?id=178261
  $breakpoint-max-range-precision: 0.02px;

  @media (max-width: $max - $breakpoint-max-range-precision) {
    @content;
  }
}

/**
 * @include gl-typescale-base(
 *  $base, // base font-size, optional
 *  $small-factor, // factor for small screens (start), optional
 *  $factor, // factor for big screens (end), optional
 *  $custom // custom size overrides, optional
 * )
 */
@mixin gl-typescale-base(
  $base: $gl-typescale-base-font-size,
  $small-factor: $gl-typescale-small-factor,
  $factor: $gl-typescale-factor,
  $custom-sizes: ()
) {
  $sizes: map-merge($gl-typescale-sizes, $custom-sizes);
  @each $name, $weight in $sizes {
    @if (str-index($name, '.')) {
      $name: str-slice($name, 2, -1);
    }

    @if not $weight {
      // ignore; do nothing.
    } @else if index('px', unit($weight)) != null {
      --gl-font-size-#{$name}: #{px-to-rem($weight)};
    } @else if $weight < 1 or $small-factor == $factor or not $small-factor {
      --gl-font-size-#{$name}: #{px-to-rem(round($base * power($factor, $weight)) + 0)};
    } @else {
      $min: px-to-rem($base * power($small-factor, $weight) + 0);
      $max: px-to-rem($base * power($factor, $weight) + 0);
      --gl-font-size-#{$name}: #{clamp-between($min, $max)};
    }

    @if $weight and index('px', unit($weight)) == null {
      --gl-font-weight-#{$name}: #{round(
          $gl-typescale-base-font-weight + ($gl-typescale-font-weight-step * $weight)
        )};
    }
  }
}

@mixin gl-typescale() {
  @include gl-typescale-base;
}

@mixin gl-typescale-fixed() {
  @include gl-typescale-base(
    $small-factor: false,
    $factor: 1.067,
    $custom-sizes: (
      // Override h1 factor.
      h1: 8,
      // Override h2 factor.
      h2: 6,
      // Remove h-display.
      'h-display': false,
    )
  );
}
